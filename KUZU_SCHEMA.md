# Kuzu Database Schema for C++ AST Analysis

This document describes the graph database schema generated by MakeIndex when analyzing C++ codebases. The schema captures the Abstract Syntax Tree (AST) structure, type relationships, inheritance hierarchies, template specializations, and semantic relationships in C++ code.

## Overview

MakeIndex generates a graph database in Kuzu format that represents C++ source code as interconnected nodes and relationships. The schema is designed to support:

- **Code Navigation**: Find declarations, definitions, usages, and dependencies
- **Architecture Analysis**: Understand inheritance hierarchies and relationships
- **Template Analysis**: Track template instantiations and specializations
- **Documentation Extraction**: Access comments and documentation
- **Static Analysis**: Query compile-time evaluations and assertions

## Core Node Types

### ASTNode (Base Node)
The fundamental node type from which all AST elements derive.

```cypher
ASTNode {
  node_id: INT64 PRIMARY KEY,        // Unique identifier
  node_type: STRING,                 // Type of AST node (e.g., "FunctionDecl", "CXXRecordDecl")
  memory_address: STRING,            // Hex address of clang AST node
  source_file: STRING,               // Source file path
  start_line: INT64,                 // Starting line number
  start_column: INT64,               // Starting column number
  end_line: INT64,                   // Ending line number  
  end_column: INT64,                 // Ending column number
  is_implicit: BOOLEAN,              // True if compiler-generated
  raw_text: STRING                   // Source text (when available)
}
```

**C++ Mapping**: Every C++ construct (declarations, statements, expressions, types) becomes an ASTNode.

### Declaration
Represents named C++ entities like variables, functions, classes, namespaces.

```cypher
Declaration {
  node_id: INT64 PRIMARY KEY,        // Links to ASTNode
  name: STRING,                      // Simple name
  qualified_name: STRING,            // Fully qualified name (e.g., "std::vector::push_back")
  access_specifier: STRING,          // "public", "private", "protected", "none"
  storage_class: STRING,             // "static", "extern", "auto", "register", etc.
  is_definition: BOOLEAN,            // True if this is a definition (not just declaration)
  namespace_context: STRING          // Enclosing namespace/class context
}
```

**C++ Mapping**:
- Classes → CXXRecordDecl nodes
- Functions → FunctionDecl nodes  
- Variables → VarDecl nodes
- Namespaces → NamespaceDecl nodes
- Templates → TemplateDecl variants

### Type
Represents C++ type information.

```cypher
Type {
  node_id: INT64 PRIMARY KEY,        // Unique type identifier
  type_name: STRING,                 // Type name (e.g., "int", "std::vector<int>")
  canonical_type: STRING,            // Canonical type representation
  size_bytes: INT64,                 // Size in bytes (-1 if unknown)
  is_const: BOOLEAN,                 // Has const qualifier
  is_volatile: BOOLEAN,              // Has volatile qualifier
  is_builtin: BOOLEAN                // True for built-in types (int, char, etc.)
}
```

**C++ Mapping**:
- Built-in types: `int`, `char`, `double`, etc.
- User-defined types: classes, structs, enums
- Template instantiations: `std::vector<int>`, `MyClass<T>`
- Pointer/reference types: `int*`, `const string&`

### Statement
Represents C++ statements and control flow constructs.

```cypher
Statement {
  node_id: INT64 PRIMARY KEY,        // Links to ASTNode
  statement_kind: STRING,            // Type of statement (e.g., "IfStmt", "ForStmt")
  has_side_effects: BOOLEAN,         // May modify program state
  is_compound: BOOLEAN,              // Contains multiple statements
  control_flow_type: STRING,         // "conditional", "loop", "jump", "sequential"
  condition_text: STRING,            // Condition expression text (for if/while/for)
  is_constexpr: BOOLEAN              // Evaluated at compile time
}
```

**C++ Mapping**:
- Control flow: `if`, `while`, `for`, `switch`
- Jumps: `return`, `break`, `continue`, `goto`
- Compound: `{ }` blocks
- Declarations: `int x = 5;`

### Expression
Represents C++ expressions and computations.

```cypher
Expression {
  node_id: INT64 PRIMARY KEY,        // Links to ASTNode
  expression_kind: STRING,           // Type of expression (e.g., "BinaryOperator", "CallExpr")
  value_category: STRING,            // "lvalue", "rvalue", "xvalue", "prvalue"
  literal_value: STRING,             // Value for literals (e.g., "42", "hello")
  operator_kind: STRING,             // Operator type ("+", "->", "[]", etc.)
  is_constexpr: BOOLEAN,             // Can be evaluated at compile time
  evaluation_result: STRING,         // Compile-time evaluation result
  implicit_cast_kind: STRING         // Type of implicit conversion applied
}
```

**C++ Mapping**:
- Literals: `42`, `"hello"`, `true`
- Operators: `a + b`, `obj->method()`, `arr[index]`
- Function calls: `foo(args)`
- Member access: `obj.member`, `ptr->member`



## Specialized Node Types

### TemplateParameter
Represents template parameters and arguments.

```cypher
TemplateParameter {
  node_id: INT64 PRIMARY KEY,
  parameter_kind: STRING,            // "type", "non_type", "template"
  parameter_name: STRING,            // Parameter name (e.g., "T", "N")
  has_default_argument: BOOLEAN,     // Has default value
  default_argument_text: STRING,     // Default argument text
  is_parameter_pack: BOOLEAN         // Variadic parameter (T...)
}
```

### UsingDeclaration
Tracks using declarations and namespace aliases.

```cypher
UsingDeclaration {
  node_id: INT64 PRIMARY KEY,
  using_kind: STRING,                // "using_decl", "using_directive", "namespace_alias"
  target_name: STRING,               // What is being imported
  introduces_name: STRING,           // Name introduced into current scope
  scope_impact: STRING               // Impact on name lookup
}
```

### MacroDefinition
Preprocessor macro information.

```cypher
MacroDefinition {
  node_id: INT64 PRIMARY KEY,
  macro_name: STRING,                // Macro name
  is_function_like: BOOLEAN,         // Function-like macro
  parameter_count: INT64,            // Number of parameters
  parameter_names: STRING,           // Parameter names (comma-separated)
  replacement_text: STRING,          // Macro body
  is_builtin: BOOLEAN,               // Compiler builtin macro
  is_conditional: BOOLEAN            // Used in conditional compilation
}
```

### IncludeDirective
Header file inclusion tracking.

```cypher
IncludeDirective {
  node_id: INT64 PRIMARY KEY,
  include_path: STRING,              // Included file path
  is_system_include: BOOLEAN,        // System header (<>) vs user header ("")
  is_angled: BOOLEAN,                // Uses angle brackets
  resolved_path: STRING,             // Actual file path found
  include_depth: INT64               // Nesting depth of includes
}
```

### Comment
Documentation and comment extraction.

```cypher
Comment {
  node_id: INT64 PRIMARY KEY,
  comment_text: STRING,              // Full comment text
  comment_kind: STRING,              // "line", "block", "doc"
  is_documentation: BOOLEAN,         // Doxygen/documentation comment
  brief_text: STRING,                // Brief description
  detailed_text: STRING             // Detailed description
}
```

### ConstantExpression
Compile-time constant evaluation.

```cypher
ConstantExpression {
  node_id: INT64 PRIMARY KEY,
  is_constexpr_function: BOOLEAN,    // Function marked constexpr
  evaluation_context: STRING,        // Where evaluation occurred
  evaluation_result: STRING,         // Computed value
  result_type: STRING,               // Type of result
  is_compile_time_constant: BOOLEAN, // Can be used as constant
  constant_value: STRING,            // Literal value
  constant_type: STRING,             // Type of constant
  evaluation_status: STRING          // "success", "failed", "unevaluated"
}
```

### CFGBlock
Control Flow Graph block representing a basic block in function control flow.

```cypher
CFGBlock {
  node_id: INT64 PRIMARY KEY,        // Unique block identifier
  function_id: INT64,                // Function containing this block
  block_index: INT64,                // Index within the CFG
  is_entry_block: BOOLEAN,           // True if this is the function entry
  is_exit_block: BOOLEAN,            // True if this is the function exit
  terminator_kind: STRING,           // Type of terminator statement
  block_content: STRING,             // Statements in this block
  condition_expression: STRING,      // Condition for conditional blocks
  has_terminator: BOOLEAN,           // True if block has terminator
  reachable: BOOLEAN                 // True if block is reachable
}
```

**C++ Mapping**:
- Function entry/exit points
- Basic blocks containing sequential statements
- Conditional branches (if/else)
- Loop headers and bodies
- Switch cases
- Exception handling blocks

## Relationship Types

### Core Relationships

#### PARENT_OF
```cypher
PARENT_OF {
  FROM ASTNode TO ASTNode,
  child_index: INT64,                // Order among siblings
  relationship_kind: STRING          // Nature of parent-child relationship
}
```
**Usage**: Represents AST hierarchy (function contains statements, class contains methods)

#### HAS_TYPE  
```cypher
HAS_TYPE {
  FROM Declaration TO Type,
  type_role: STRING                  // "return_type", "parameter_type", "member_type"
}
```
**Usage**: Links declarations to their types (variable has int type, function has return type)

#### REFERENCES
```cypher
REFERENCES {
  FROM ASTNode TO Declaration,
  reference_kind: STRING,            // "call", "variable_use", "type_reference"
  is_direct: BOOLEAN                 // Direct vs indirect reference
}
```
**Usage**: Tracks where declarations are used (function calls, variable references)

#### IN_SCOPE
```cypher
IN_SCOPE {
  FROM ASTNode TO Declaration,
  scope_kind: STRING                 // "namespace", "class", "function", "block"
}
```
**Usage**: Defines scoping relationships (what's visible where)

### Inheritance Relationships

#### INHERITS_FROM
```cypher
INHERITS_FROM {
  FROM Declaration TO Declaration,
  inheritance_type: STRING,          // "public", "private", "protected"
  is_virtual: BOOLEAN,               // Virtual inheritance
  base_access_path: STRING           // How to access base members
}
```
**Usage**: Class inheritance relationships

#### OVERRIDES
```cypher
OVERRIDES {
  FROM Declaration TO Declaration,
  override_type: STRING,             // "virtual", "pure_virtual", "final"
  is_covariant_return: BOOLEAN       // Return type covariance
}
```
**Usage**: Virtual function overriding

### Template Relationships

#### TEMPLATE_RELATION
```cypher
TEMPLATE_RELATION {
  FROM ASTNode TO Declaration,
  relation_kind: STRING,             // "specializes", "instantiates", "depends_on"
  specialization_type: STRING        // Type of template relationship
}
```

#### SPECIALIZES
```cypher
SPECIALIZES {
  FROM Declaration TO Declaration,
  specialization_kind: STRING,       // "implicit", "explicit_declaration", "explicit_definition"
  template_arguments: STRING,        // Actual template arguments
  instantiation_context: STRING      // Where specialization occurred
}
```

### Preprocessor Relationships

#### MACRO_EXPANSION
```cypher
MACRO_EXPANSION {
  FROM ASTNode TO MacroDefinition,
  expansion_context: STRING,         // Where macro was expanded
  expansion_arguments: STRING        // Arguments passed to macro
}
```

#### INCLUDES
```cypher
INCLUDES {
  FROM ASTNode TO IncludeDirective,
  include_order: INT64               // Order of inclusion
}
```

### Control Flow Graph Relationships

#### CFG_EDGE
```cypher
CFG_EDGE {
  FROM CFGBlock TO CFGBlock,
  edge_type: STRING,                 // "conditional", "loop", "unconditional", "return", etc.
  condition: STRING                  // Condition expression for conditional edges
}
```
**Usage**: Represents control flow between CFG blocks

#### CONTAINS_CFG
```cypher
CONTAINS_CFG {
  FROM Declaration TO CFGBlock,
  cfg_role: STRING                   // "block" - indicates function contains CFG block
}
```
**Usage**: Links functions to their CFG blocks

#### CFG_CONTAINS_STMT
```cypher
CFG_CONTAINS_STMT {
  FROM CFGBlock TO Statement,
  statement_index: INT64             // Order of statement within block
}
```
**Usage**: Links CFG blocks to the statements they contain

## Example C++ Code Mappings

### Class Declaration
```cpp
class MyClass : public BaseClass {
private:
    int member_var;
public:
    void method();
};
```

**Database Representation**:
- `MyClass` → Declaration node (node_type="CXXRecordDecl")
- `BaseClass` → Declaration node  
- `INHERITS_FROM` relationship: MyClass → BaseClass
- `member_var` → Declaration node (node_type="FieldDecl")
- `method` → Declaration node (node_type="CXXMethodDecl")
- `PARENT_OF` relationships: MyClass contains member_var and method

### Template Specialization
```cpp
template<typename T> class Container {};
template<> class Container<int> { /* specialized */ };
Container<int> instance;
```

**Database Representation**:
- Primary template → Declaration node (ClassTemplateDecl)
- Specialization → Declaration node (ClassTemplateSpecializationDecl)
- `SPECIALIZES` relationship linking them
- `instance` → Declaration with `HAS_TYPE` to specialized Container<int>

### Function Call
```cpp
int result = myFunction(arg1, arg2);
```

**Database Representation**:
- `result` → Declaration (VarDecl)
- Function call → Expression (CallExpr)
- `REFERENCES` relationship: CallExpr → myFunction Declaration
- `HAS_TYPE` relationship: result → int Type

## Query Examples

### Find All Classes in a Namespace
```cypher
MATCH (ns:Declaration {node_type: "NamespaceDecl", name: "MyNamespace"})
      -[:PARENT_OF*]->
      (cls:Declaration {node_type: "CXXRecordDecl"})
RETURN cls.name, cls.qualified_name
```

### Find All Virtual Functions That Are Overridden
```cypher
MATCH (base:Declaration)-[:OVERRIDES]->(derived:Declaration)
WHERE base.node_type = "CXXMethodDecl"
RETURN base.qualified_name AS base_method, 
       derived.qualified_name AS overriding_method
```

### Find Template Specializations
```cypher
MATCH (spec:Declaration)-[r:SPECIALIZES]->(template:Declaration)
RETURN template.name AS template_name,
       spec.name AS specialization_name,
       r.template_arguments AS args,
       r.specialization_kind AS kind
```



### Find Functions Called from a Specific Function
```cypher
MATCH (caller:Declaration {node_type: "FunctionDecl", name: "myFunction"})
      -[:PARENT_OF*]->
      (call:Expression {expression_kind: "CallExpr"})
      -[:REFERENCES]->
      (callee:Declaration {node_type: "FunctionDecl"})
RETURN DISTINCT callee.qualified_name AS called_function
```

### Find All Classes That Use a Specific Type
```cypher
MATCH (cls:Declaration {node_type: "CXXRecordDecl"})
      -[:PARENT_OF*]->
      (member:Declaration)
      -[:HAS_TYPE]->
      (type:Type {type_name: "std::string"})
RETURN cls.qualified_name AS class_name, 
       member.name AS member_name
```

### Find Inheritance Hierarchies
```cypher
MATCH path = (derived:Declaration)-[:INHERITS_FROM*]->(base:Declaration)
WHERE derived.node_type = "CXXRecordDecl" AND base.node_type = "CXXRecordDecl"
RETURN derived.qualified_name AS derived_class,
       [node IN nodes(path) | node.qualified_name] AS inheritance_chain
```

### Find Template Dependencies
```cypher
MATCH (template:Declaration {node_type: "ClassTemplateDecl"})
      -[:SPECIALIZES|TEMPLATE_RELATION*]->
      (dependency:Declaration)
RETURN template.qualified_name AS template_name,
       collect(DISTINCT dependency.qualified_name) AS dependencies
```

### Find All Static Assertions
```cypher
MATCH (assert:StaticAssertion)
      <-[:CONTAINS_STATIC_ASSERT]-
      (container:Declaration)
RETURN container.qualified_name AS context,
       assert.assertion_expression AS condition,
       assert.assertion_message AS message,
       assert.assertion_result AS passed
```

### Find Include Dependencies
```cypher
MATCH (file:ASTNode {source_file: "main.cpp"})
      -[:INCLUDES]->
      (include:IncludeDirective)
RETURN include.include_path AS included_file,
       include.is_system_include AS is_system,
       include.include_depth AS depth
ORDER BY include.include_order
```

### Find Unused Variables
```cypher
MATCH (var:Declaration {node_type: "VarDecl"})
WHERE NOT exists((var)<-[:REFERENCES]-())
RETURN var.qualified_name AS unused_variable,
       var.source_file AS file,
       var.start_line AS line
```

### Find Complex Template Instantiations
```cypher
MATCH (instantiation:Declaration)
      -[spec:SPECIALIZES]->
      (template:Declaration)
WHERE spec.specialization_kind = "implicit"
  AND size(spec.template_arguments) > 50  // Complex templates
RETURN template.qualified_name AS template_name,
       instantiation.qualified_name AS instance_name,
       spec.template_arguments AS arguments
```

## Control Flow Graph Examples

### Function with Control Flow
```cpp
int example(int x) {
    if (x > 0) {
        return x;
    } else {
        return -x;
    }
}
```

**Database Representation**:
- Entry block → CFGBlock (is_entry_block=true)
- Condition block → CFGBlock (block_content="if (x > 0)")
- True branch → CFGBlock (block_content="return x")
- False branch → CFGBlock (block_content="return -x")  
- Exit block → CFGBlock (is_exit_block=true)

### Loop Control Flow
```cpp
int sum(int n) {
    int total = 0;
    for (int i = 0; i < n; i++) {
        total += i;
    }
    return total;
}
```

**Database Representation**:
- Initialization → CFGBlock (block_content="int total = 0; int i = 0")
- Loop condition → CFGBlock (condition_expression="i < n", terminator_kind="ForStmt")
- Loop body → CFGBlock (block_content="total += i")
- Increment → CFGBlock (block_content="i++")
- Return → CFGBlock (block_content="return total")

### CFG Query Examples

#### Find All Functions with Loops
```cypher
MATCH (func:Declaration {node_type: "FunctionDecl"})
      -[:CONTAINS_CFG]->
      (block:CFGBlock)
WHERE block.terminator_kind IN ["ForStmt", "WhileStmt", "DoStmt"]
RETURN func.qualified_name AS function_name,
       block.condition_expression AS loop_condition
```

#### Find Functions with Complex Control Flow
```cypher
MATCH (func:Declaration {node_type: "FunctionDecl"})
      -[:CONTAINS_CFG]->
      (block:CFGBlock)
WITH func, count(block) AS block_count
WHERE block_count > 5  // Functions with many blocks
RETURN func.qualified_name AS complex_function,
       block_count AS num_blocks
ORDER BY block_count DESC
```

#### Trace Control Flow Paths
```cypher
MATCH path = (entry:CFGBlock {is_entry_block: true})
             -[:CFG_EDGE*]->
             (exit:CFGBlock {is_exit_block: true})
WHERE entry.function_id = exit.function_id
RETURN [block IN nodes(path) | block.block_content] AS control_flow_path,
       length(path) AS path_length
```

#### Find Unreachable Code
```cypher
MATCH (func:Declaration {node_type: "FunctionDecl"})
      -[:CONTAINS_CFG]->
      (block:CFGBlock {reachable: false})
RETURN func.qualified_name AS function_name,
       block.block_content AS unreachable_code,
       block.block_index AS block_position
```

#### Analyze Conditional Branches
```cypher
MATCH (block:CFGBlock)
      -[edge:CFG_EDGE {edge_type: "conditional"}]->
      (successor:CFGBlock)
RETURN block.condition_expression AS condition,
       edge.condition AS branch_condition,
       successor.block_content AS branch_code
```

#### Find Functions with No Return Paths
```cypher
MATCH (func:Declaration {node_type: "FunctionDecl"})
      -[:CONTAINS_CFG]->
      (entry:CFGBlock {is_entry_block: true})
WHERE NOT EXISTS {
  MATCH (entry)-[:CFG_EDGE*]->(exit:CFGBlock {is_exit_block: true})
}
RETURN func.qualified_name AS function_with_no_return
```
